import {
  getAuth,
  createUserWithEmailAndPassword,
  onAuthStateChanged,
  updateProfile,
} from 'firebase/auth';
import {
  collection,
  doc,
  setDoc,
  getDoc,
  getDocs,
  getFirestore,
  updateDoc,
} from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { useContext, useEffect, useState } from 'react';
import { loginProps, userProps } from '../../interface';
import { auth, db, storage } from '../../Firebase';
import { errorAlert, isAuthenticated, successAlert } from '../../utils';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '..';
import { getLoginToken } from '../../Storage';
import { axiosInstance } from '../../axios-Instance';
import { useQuery } from '@tanstack/react-query';
import { queryKeys } from '../../react-query/constants';

export function useRegisterUser(formData: loginProps) {
  const [mutate, setMutate] = useState(false);
  const [error, setError] = useState(null);
  const [isSuccess, setIsSuccess] = useState(false);
  const navigate = useNavigate();
  useEffect(() => {
    if (mutate) {
      const registerUser = async () => {
        try {
          const userCredential = await createUserWithEmailAndPassword(
            auth,
            formData.email,
            formData.password
          );
          const user = userCredential.user;
          const userId = `user${Date.now()}`;
          const userData = {
            ...formData,
            id: userId,
          };

          await setDoc(doc(db, 'users', user.uid), userData).then(() => {
            setIsSuccess(true);
            successAlert('registration successful');
            navigate('/login');
          });
        } catch (error: any) {
          setError(error as any);
          errorAlert(error.message);
          setIsSuccess(false);
        } finally {
          setMutate(false);
        }
      };
      registerUser();
    }
  }, []);

  return { mutate: () => setMutate(true), error, isSuccess };
}

// Get the currently signed-in user
export function getAuthenticated() {
  const auth = getAuth();
  onAuthStateChanged(auth, (user) => {
    if (user) {
      const uid = user.uid;

      return { user, uid, isSuccess: true };
    } else {
      return { isSuccess: false };
    }
  });
}

export function getProfile() {
  const auth = getAuth();
  const user = auth.currentUser;
  if (user !== null) {
    const displayName = user.displayName;
    const email = user.email;
    const photoURL = user.photoURL;
    const emailVerified = user.emailVerified;
    const uid = user.uid;

    return { user, displayName, email, photoURL, emailVerified, uid, isSuccess: true };
  } else {
    return { isSuccess: false };
  }
}

export async function updateMe(formData: userProps) {
  const auth = getAuth();
  const { displayName, photo, ...otherData } = formData;

  let photoURL = '';
  if (photo) {
    const photoRef = ref(storage, `photos/${auth?.currentUser?.uid}`);
    const photoBlob = new Blob([photo]);
    await uploadBytes(photoRef, photoBlob);
    photoURL = await getDownloadURL(photoRef);
  }

  try {
    const currentUser = auth.currentUser;
    if (currentUser) {
      await updateProfile(currentUser, {
        displayName,
        photoURL,
      });

      const userDoc = doc(db, 'users', currentUser.uid);
      await updateDoc(userDoc, {
        ...otherData,
        photo: photoURL,
      });

      console.log('Profile updated!');
    }
  } catch (error) {
    console.error('Error updating profile:', error);
  }
}

// currently signed-in user by using the currentUser property
export function getMe() {
  const auth = getAuth();
  const user = auth.currentUser;

  if (user) {
    const uid = user.uid;
    const email = user.email;
    const displayName = user.displayName;
    const photoURL = user.photoURL;
    const emailVerified = user.emailVerified;

    return { user, uid, email, displayName, photoURL, emailVerified, isSuccess: true };
  } else {
    return { isSuccess: false };
  }
}
export function useFetchCandidates() {
  const [allCandidates, setAllCandidates] = useState([]);

  useEffect(() => {
    async function getCandidates() {
      try {
        const candidatesCollection = collection(db, 'candidates');
        const snapshot = await getDocs(candidatesCollection);
        const candidates = snapshot.docs.map((doc: { data: () => any }) => doc.data());
        setAllCandidates(candidates as any);
      } catch (error) {
        console.error('Error fetching candidates:', error);
      }
    }

    getCandidates();
  }, []);

  return allCandidates;
}

export function useFetchUsers() {
  const [allCandidates, setAllCandidates] = useState([]);

  useEffect(() => {
    async function getCandidates() {
      try {
        const candidatesCollection = collection(db, 'users');
        const snapshot = await getDocs(candidatesCollection);
        const candidates = snapshot.docs.map((doc: { data: () => any }) => doc.data());
        setAllCandidates(candidates as any);
      } catch (error) {
        console.error('Error fetching users:', error);
      }
    }

    getCandidates();
  }, []);

  return allCandidates;
}

export function useFetchAllUsers() {
  const [allUsers, setAllUser] = useState<userProps[]>([]);

  useEffect(() => {
    const roles = ['Admin', 'Instructor', 'User'];

    async function getUsers() {
      let users: userProps[] = [];

      try {
        for (const role of roles) {
          const candidatesCollection = collection(db, role);
          const snapshot = await getDocs(candidatesCollection);
          const userRoles = snapshot.docs.map(
            (doc) => ({ id: doc.id, ...doc.data() } as userProps)
          );
          users = users.concat(userRoles);
        }
        setAllUser(users);
      } catch (error) {
        console.error('Error fetching users:', error);
      }
    }

    getUsers();
  }, []);

  return allUsers;
}

export function useFetchVotes() {
  const [allCandidates, setAllCandidates] = useState([]);

  useEffect(() => {
    async function getCandidates() {
      try {
        const candidatesCollection = collection(db, 'votes');
        const snapshot = await getDocs(candidatesCollection);
        const candidates = snapshot.docs.map((doc: { data: () => any }) => doc.data());
        setAllCandidates(candidates as any);
      } catch (error) {
        console.error('Error fetching votes:', error);
      }
    }

    getCandidates();
  }, []);

  return allCandidates;
}

// AuthContextProvider used for firebase authentication

import React, { createContext, useEffect, useState } from 'react';
import {
  browserLocalPersistence,
  getAuth,
  onAuthStateChanged,
  setPersistence,
} from 'firebase/auth';
import { doc, getDoc } from 'firebase/firestore';
import { useQueryClient } from '@tanstack/react-query';
import { ChildProps, userProps } from '../interface';
import { getStoredUser, setStoredUser } from '../Storage';
import { db } from '../Firebase';
import { queryKeys } from '../react-query/constants';

export const AuthContext = createContext<{
  user: userProps | null;
  token: string | undefined;
  isAuthenticated: boolean;
  isLoading: boolean;
  authenticate: (token: string) => void;
  logout: () => void;
}>({
  user: null,
  token: undefined,
  isAuthenticated: false,
  isLoading: true,
  authenticate: () => {},
  logout: () => {},
});

function AuthContextProvider({ children }: ChildProps) {
  const [authToken, setAuthToken] = useState<string | undefined>(undefined);
  const [user, setUser] = useState<userProps | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const queryClient = useQueryClient();
  const auth = getAuth();

  function logout() {
    setUser(null);
    setAuthToken(undefined);
    localStorage.clear();
    queryClient.invalidateQueries([queryKeys.user]);
  }

  useEffect(() => {
    setPersistence(auth, browserLocalPersistence).then(() => {});

    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      if (firebaseUser) {
        const token = await firebaseUser.getIdToken();
        setAuthToken(token);

        const userDocRef = doc(db, 'users', firebaseUser.uid);
        const userDoc = await getDoc(userDocRef);
        if (userDoc.exists()) {
          const userData = userDoc.data() as userProps;
          setUser({ ...(firebaseUser.toJSON() as any), ...userData });
          setStoredUser({ ...firebaseUser.toJSON(), ...userData });
          localStorage.setItem('user', JSON.stringify({ ...firebaseUser.toJSON(), ...userData }));
        } else {
          setUser(firebaseUser.toJSON() as any);
          setStoredUser(firebaseUser.toJSON() as any);
          localStorage.setItem('user', JSON.stringify(firebaseUser.toJSON()));
        }
      } else {
        setUser(null);
        setAuthToken(undefined);
      }
      setIsLoading(false);
    });

    return () => unsubscribe();
  }, [auth]);

  useEffect(() => {
    const storedUser = localStorage.getItem('user');
    if (storedUser) {
      setUser(JSON.parse(storedUser));
    }
    setIsLoading(false);
  }, []);

  function authenticate(token: string) {
    setAuthToken(token);
  }

  const value = {
    user,
    token: authToken,
    isAuthenticated: !!authToken,
    isLoading,
    authenticate,
    logout,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export default AuthContextProvider;
